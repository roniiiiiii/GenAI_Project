# -*- coding: utf-8 -*-
"""thematic_clusters

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-tded12CeHILpoAitE8B72Np8hJaLa8b
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.manifold import TSNE
from sklearn.cluster import KMeans
from sklearn.metrics import pairwise_distances
from sklearn.preprocessing import StandardScaler
from PIL import Image
import os
import plotly.express as px
import plotly.graph_objects as go
from umap import UMAP
from openai import OpenAI  # Import OpenAI client

def explore_thematic_clusters(metadata_df, image_vectors, openai_api_key=None):
    st.title("Thematic Clusters Explorer")
    st.markdown("""
    Discover visual themes across the collection. Artworks are grouped by:
    - Symbolic elements
    - Composition styles
    - Color palettes
    - Recurring motifs
    """)

    # Validate inputs
    if not isinstance(image_vectors, dict):
        st.error("Invalid image vectors format. Expected a dictionary.")
        return

    if metadata_df.empty:
        st.error("No metadata available.")
        return

    # Create consistent image vector matrix
    valid_images = []
    embeddings = []

    for image_file, vector in image_vectors.items():
        # Handle different filename formats (with/without extension)
        base_name = image_file.split('.')[0]

        # Check if this image exists in metadata
        if any(metadata_df['id'].astype(str).str.contains(base_name)):
            valid_images.append(image_file)
            embeddings.append(vector)

    if not valid_images:
        st.warning("No valid image vectors found for clustering")
        return

    # Create embedding matrix
    embedding_matrix = np.array(embeddings)

    # Dimensionality reduction options
    st.sidebar.header("Clustering Parameters")
    method = st.sidebar.selectbox("Visualization Method",
                                 ["t-SNE", "UMAP", "PCA"],
                                 index=0)

    n_clusters = st.sidebar.slider("Number of Themes",
                                  min_value=3,
                                  max_value=12,
                                  value=6,
                                  help="Adjust to discover broader or more specific themes")

    # Nationality filter
    nationalities = ["All"] + sorted(metadata_df['nationality'].dropna().unique().tolist())
    selected_nationality = st.sidebar.selectbox("Filter by Nationality", nationalities, index=0)

    # Perform clustering
    try:
        kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
        clusters = kmeans.fit_predict(embedding_matrix)
    except Exception as e:
        st.error(f"Clustering failed: {str(e)}")
        return

    # Dimensionality reduction
    try:
        if method == "t-SNE":
            reducer = TSNE(n_components=2, perplexity=min(30, len(embeddings)-1), random_state=42)
        elif method == "UMAP":
            reducer = UMAP(n_components=2, random_state=42)
        else:  # PCA
            from sklearn.decomposition import PCA
            reducer = PCA(n_components=2)

        coords = reducer.fit_transform(embedding_matrix)
    except Exception as e:
        st.error(f"Dimensionality reduction failed: {str(e)}")
        return

    # Create dataframe for visualization
    plot_df = pd.DataFrame({
        'x': coords[:, 0],
        'y': coords[:, 1],
        'cluster': clusters,
        'image': valid_images
    })

    # Try to match on filename without extension
    plot_df['base_name'] = plot_df['image'].apply(lambda x: x.split('.')[0])

    # Handle metadata merge more robustly
    if 'id' in metadata_df.columns:
        metadata_df['base_name'] = metadata_df['id'].astype(str).apply(lambda x: x.split('.')[0])
        plot_df = plot_df.merge(
            metadata_df,
            on='base_name',
            how='left'
        )

        # Rename columns to match expected names
        if 'name' in plot_df.columns:
            plot_df.rename(columns={'name': 'title'}, inplace=True)
    else:
        st.warning("No 'id' column found in metadata. Limited metadata available.")
        # Add placeholder columns
        plot_df['title'] = 'Unknown'
        plot_df['artist'] = 'Unknown'
        plot_df['year'] = 'Unknown'
        plot_df['nationality'] = 'Unknown'

    # Apply nationality filter
    if selected_nationality != "All" and 'nationality' in plot_df.columns:
        plot_df = plot_df[plot_df['nationality'] == selected_nationality]

    # Generate theme labels using AI if API key is available
    theme_labels = {}
    if openai_api_key:
        try:
            # Create OpenAI client with new API
            client = OpenAI(api_key=openai_api_key)

            for cluster_id in range(n_clusters):
                cluster_df = plot_df[plot_df['cluster'] == cluster_id]
                sample_titles = cluster_df['title'].dropna().unique().tolist()[:3]
                sample_artists = cluster_df['artist'].dropna().unique().tolist()[:3]

                if sample_titles and sample_artists:
                    prompt = f"""
                    As a feminist art historian, identify the common visual theme in these artworks:

                    Titles: {", ".join(sample_titles)}
                    Artists: {", ".join(sample_artists)}

                    Identify 1-3 keywords that capture the shared visual theme. Focus on:
                    - Symbolic elements
                    - Composition style
                    - Color palette
                    - Emotional tone

                    Respond ONLY with the keywords separated by commas. Example: "Fragmented bodies, Earth tones, Introspection"
                    """

                    # Use new API format
                    response = client.chat.completions.create(
                        model="gpt-3.5-turbo",
                        messages=[
                            {"role": "system", "content": "You are an expert in feminist art history."},
                            {"role": "user", "content": prompt}
                        ],
                        max_tokens=50,
                        temperature=0.3
                    )
                    theme_labels[cluster_id] = response.choices[0].message.content.strip()
                else:
                    theme_labels[cluster_id] = f"Theme {cluster_id}"
        except Exception as e:
            st.warning(f"Couldn't generate theme labels: {str(e)}")
            # Fallback to numbered themes
            theme_labels = {i: f"Theme {i}" for i in range(n_clusters)}
    else:
        # Create default numbered theme labels
        theme_labels = {i: f"Theme {i}" for i in range(n_clusters)}

    # Map cluster IDs to theme labels
    plot_df['theme_label'] = plot_df['cluster'].map(theme_labels)

    # Interactive cluster visualization
    st.subheader(f"Visual Theme Exploration ({method})")
    try:
        # Check which columns actually exist
        hover_columns = []
        for col in ['title', 'artist', 'year', 'nationality', 'theme_label']:
            if col in plot_df.columns:
                hover_columns.append(col)

        fig = px.scatter(
            plot_df,
            x='x',
            y='y',
            color='theme_label',
            hover_data=hover_columns,
            color_discrete_sequence=px.colors.qualitative.Pastel,
            labels={'theme_label': 'Visual Theme'}
        )

        fig.update_layout(
            hovermode='closest',
            showlegend=True,
            height=600,
            legend_title_text='Visual Themes'
        )
        st.plotly_chart(fig, use_container_width=True)
    except Exception as e:
        st.error(f"Failed to create visualization: {str(e)}")

    # Cluster gallery view
    st.subheader("Explore Visual Themes")

    # Sort clusters by size
    cluster_sizes = plot_df['cluster'].value_counts().sort_values(ascending=False)

    for cluster_id in cluster_sizes.index:
        cluster_df = plot_df[plot_df['cluster'] == cluster_id]
        cluster_size = len(cluster_df)
        theme_label = theme_labels.get(cluster_id, f"Theme {cluster_id}")

        st.markdown(f"### {theme_label} ({cluster_size} artworks)")

        # Display sample images from cluster
        cols = st.columns(min(4, cluster_size))
        for idx, (_, row) in enumerate(cluster_df.iterrows()):
            if idx >= 4:  # Only show first 4
                break

            with cols[idx % len(cols)]:
                try:
                    img_path = os.path.join("images", row['image'])
                    if os.path.exists(img_path):
                        img = Image.open(img_path)
                        st.image(img, use_container_width=True)
                        st.caption(f"{row.get('title', 'Untitled')} by {row.get('artist', 'Unknown')}")
                    else:
                        st.warning(f"Image not found: {img_path}")
                except Exception as e:
                    st.error(f"Error loading image: {str(e)}")

        # Show cluster characteristics
        with st.expander(f"Characteristics of {theme_label}"):
            if 'title' in cluster_df.columns and 'artist' in cluster_df.columns:
                sample_titles = cluster_df['title'].dropna().unique().tolist()[:5]
                sample_artists = cluster_df['artist'].dropna().unique().tolist()[:3]

                if sample_titles:
                    st.markdown(f"**Sample artworks:**")
                    st.info(f"Titles: {', '.join(sample_titles)}")
                if sample_artists:
                    st.info(f"Artists: {', '.join(sample_artists)}")

            st.markdown(f"**Visual theme characteristics:**")
            st.info("""
            Common symbolic elements: Mirrors, fragmented bodies
            Composition: Centered subjects with negative space
            Color palette: Muted earth tones with bold red accents
            Emotional tone: Introspective, challenging societal norms
            """)

    # Nationality distribution per cluster
    if 'nationality' in plot_df.columns:
        st.subheader("Nationality Distribution Across Themes")
        try:
            # Map cluster IDs to theme labels
            cluster_nat = pd.crosstab(
                plot_df['theme_label'],
                plot_df['nationality'],
                normalize='index'
            )

            fig2 = px.bar(
                cluster_nat,
                barmode='stack',
                labels={'value': 'Percentage', 'nationality': 'Nationality'},
                height=400,
                title="Nationality Distribution by Visual Theme"
            )
            st.plotly_chart(fig2, use_container_width=True)
        except Exception as e:
            st.error(f"Failed to create nationality distribution: {str(e)}")





